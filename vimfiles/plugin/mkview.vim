"        File: mkview.vim
"      Author: Srinath Avadhanula
"              (srinath@fastmail.fm)
" Description: This module provides functions to save and load the view of the
"              current file without requiring the use of mkview. To be used by
"              scripts which do not want the hassle of temporary files
"              generated by mkview.
" Last Change: Sun Feb 17 05:00 PM 2002 PST


" Synopsis: let foldInfo = MkView()
" Description: this function returns a string containing the minimal
"    information needed to restore the current view of the file. 
"    foldInfo is a string of of the form:
"      row#col#foldLineInfo#foldClosedInfo
"    where
"      row = cursor row
"      col = cursor column
"      foldLineInfo = a string of the form
"         s1,e1|s2,e2|...|sn,en
"         where 
"           si = starting line number of the i^th fold
"           ei = ending line number of the i^th fold.
"         arbitrarily deeply nested folds are allowed. The 'nestedness' is
"         captured by the order of the folds.
"      foldClosedInfo = a comma seperated string of ones and zeros.
"         the i^th element is 1 if the corresponding fold described in
"         foldLineInfo is closed, else 0.
" 
" This the most general purpose function for saving the view information of
" the file, when nothing is known about whether there are folds or not,
" whether the folds are nested etc. If some apriori information about the
" state of the folds is known, then use the two variants of this function
" described below.
function! MkView()
	let row = line('.')
	let col = virtcol('.')
	let viewInfo = row.'#'.col

	let flevelinfo = FoldLinesInfo(1)
	let flevelinfo = substitute(flevelinfo, '^|', '', '')
	let fopeninfo = FoldOpenClosedInfo(flevelinfo)

	let viewInfo = viewInfo.'#'.flevelinfo.'#'.fopeninfo
	
	exe row
	exe 'normal! '.col.'|'

	return viewInfo
endfunction

" Synopsis: let foldInfo = MkViewNoFolds()
" Description: returns the view information of the current file. THis funciton
"    should be used when its known that there are no folds. Hence it simply
"    returns the cursor row and column.
function! MkViewNoFolds()
	return line('.').'#'.virtcol('.').'##'
endfunction

" Synopsis: let foldInfo = MkViewNoNestedFolds()
" Description: returns the view information. This function is to be used when
"    it is known that there are no nested folds in the file (i.e folds with
"    depth > 1). when there are nested folds, this function silently ignores
"    them.
function! MkViewNoNestedFolds()
	let row = line('.')
	let col = virtcol('.')
	let viewInfo = row.'#'.col.'#'
	let openInfo = ''

	let i = 1
	while i <= line('$')
		if foldlevel(i) > 0
			let unfold = 0
			if foldclosedend(i) < 0
				exe i
				normal! zc
				let unfold = 1
				let openInfo = openInfo.0.','
			else
				let openInfo = openInfo.1.','
			end
			let j = foldclosedend(i)
			let viewInfo  = viewInfo.i.','.j.'|'
			if unfold
				exe i
				normal! zo
			end
			let i = j + 1
			continue
		end
		let i = i + 1
	endwhile
	
	let viewInfo = viewInfo.'#'.openInfo
	let viewInfo = substitute(viewInfo, '|#', '#', '')
	let viewInfo = substitute(viewInfo, ',$', '', '')

	exe row
	exe 'normal! '.col.'|'

	return viewInfo
endfunction

" Synopsis: call LoadView(foldInfo)
" Description: This function restores the view defined in the argument
"    foldInfo. See the description of MkView() for the format of this
"    argument. This function should only be used when the foldmethod of the
"    file is manual. There is no error-checking done in this function, so it
"    needs to be used responsibly.
function! LoadView(foldInfo)
	let row = s:Strntok(a:foldInfo, '#', 1)
	let col = s:Strntok(a:foldInfo, '#', 2)
	let folds = s:Strntok(a:foldInfo, '#', 3)
	let fclosedinfo = s:Strntok(a:foldInfo, '#', 4)
	
	normal! zE

	let i = 1
	let foldi = s:Strntok(folds, '|', i)
	let isclosed = s:Strntok(fclosedinfo, ',', i)

	while foldi != ''
		let n1 = s:Strntok(foldi, ',', 1)
		let n2 = s:Strntok(foldi, ',', 2)
		exe n1.','.n2.' fold'

		if !isclosed
			exe n1
			normal! zo
		end

		let i = i + 1
		let foldi = s:Strntok(folds, '|', i)
		let isclosed = s:Strntok(fclosedinfo, ',', i)
	endwhile

	exe row
	exe 'normal! '.col.'|'
endfunction

" end of exported functions. Internally used functions follow. These functions
" have been intentionally left globally visible in case they might also be
" useful by other scripts.

function! FoldOpenClosedInfo(folds)
	let folds = substitute(a:folds, '^|', '', '')
	let retf = ''

	let i = 1
	let foldi = s:Strntok(folds, '|', i)
	while foldi != ''
		let firstline = s:Strntok(foldi, ',', 1)
		let retf = retf.IsFoldClosed(firstline).','

		let i = i + 1
		let foldi = s:Strntok(folds, '|', i)
	endwhile

	return substitute(retf, ',$', '', '')
endfunction

function! IsFoldClosed(line)
	let flc = foldclosed(a:line)
	if flc == a:line
		return 1
	elseif flc < 0
		return 0
	elseif flc < a:line
		" if the current line is folded and foldclosed returns a number less
		" than the current line, then there are 2 possibilities. 
		" 1. the current fold is closed and so is the parent fold
		" 2. only the parent fold is closed causing this foldclosed() to return 1.
		" therefore goto the parent fold, close it and then recheck.
		exe flc
		normal! zo
		exe a:line
		let retf = IsFoldClosed(a:line)
		" close back the parent fold.
		exe flc
		normal! zc
		return retf
	end
endfunction

function! FoldLinesInfo(curLine)
	let curLevel = foldlevel(a:curLine)

	let retFold = ''
	let lineNum = a:curLine
	while lineNum <= line('$')
		
		if foldlevel(lineNum) < curLevel
			let lastLine = lineNum - 1
			break
		endif
		if foldlevel(lineNum) > curLevel
			let nestedFold = FoldLinesInfo(lineNum)
			let lastNestedLine = matchstr(nestedFold, ',\zs[0-9]\+\ze$')
			let lineNum = lastNestedLine + 1
			let retFold = retFold.nestedFold
			continue
		end
		
		let lineNum = lineNum + 1
	endwhile
	if !exists('lastLine') 
		let lastLine = lineNum - 1
	end
	if curLevel > 0
		let retFold =  retFold.'|'.a:curLine.','.lastLine
	end
	return retFold
endfunction

" Strntok:
" extract the n^th token from s seperated by tok. 
" example: Strntok('1,23,3', ',', 2) = 23
fun! <SID>Strntok(s, tok, n)
	return matchstr( a:s.a:tok[0], '\v(\zs([^'.a:tok.']*)\ze['.a:tok.']){'.a:n.'}')
endfun

