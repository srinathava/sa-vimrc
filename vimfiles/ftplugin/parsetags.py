import time
from threading import Thread
import re
import os

class Container:
    def __init__(self, name, type, parent, info=None):
        self.name = name
        self.type = type
        self.parent = parent
        self.info = info

        # These are all the children of this container. These are
        # containers themselves. We use a dictionary here to map the
        # "names" of the children to the actual objects. Note that multiple
        # children can share the same name (in case of function
        # overloading). Therefore, the value of this dictionary is a list
        # containing all objects which share the name.
        self.children = {}

        self.constre = re.compile(r'\bconst|virtual|inline\b')

    def parseFile(self, fileName):
        # Note that we depend on the tags being generated using the command
        #   > ctags -R --fields=+iaS testtags.cpp

        taglines = open(fileName).readlines()

        # skip to the first non-comment line
        firstTagLine = 0
        while taglines[firstTagLine][0] == '!':
            firstTagLine += 1

        # if there is no comment at all, this is probably a tags file
        # generated by some other means.
        if firstTagLine == 0:
            return

        for line in taglines[firstTagLine:]:
            mandatory, optional = line.split(';"\t')

            tag, file, location = mandatory.split("\t", 2)
            otherFields = optional.split("\t",)
            type = otherFields[0]
            
            if type == 'p':
                # do not bother with prototypes. We will get to the actual
                # definition later...
                continue

            # build a dictionary from all other information present in the tags
            # file.
            info = otherFields[1:]
            infoDict = {}
            for infoItem in info:
                key, value = infoItem.split(':', 1)
                infoDict[key] = value.strip()

            infoDict['file'] = file
            infoDict['location'] = location

            if type == 'f' or type == 'm':
                location = self.constre.sub('', location)
                returnType = location[2:].split(None,1)[0]
                if returnType[-1] == '*':
                    returnType = returnType[:-1]
                infoDict['returnType'] = returnType
            elif type == 't':
                vimDebug('location = %s' % location)
                # infoDict['typedef'] = location.split(None,2)[1]
            else:
                infoDict['returnType'] = None

            if 'class' in infoDict:
                path = infoDict['class'].split('::')
            elif 'namespace' in infoDict:
                path = infoDict['namespace'].split('::')
            elif 'enum' in infoDict:
                path = infoDict['enum'].split('::')
            elif 'struct' in infoDict:
                path = infoDict['struct'].split('::')
            elif 'union' in infoDict:
                path = infoDict['union'].split('::')
            else:
                path = []

            # print 'adding %s with info = %s' % (tag, infoDict)
            self.add(tag, type, path, infoDict)
            # for enums, C/C++ have completely flat scoping. This is
            # probably not right with enums declared in namespaces, but
            # that will require way too much cleverness.
            if type == 'e':
                self.add(tag, type, [], infoDict)

        # just for fun, sleep for a few seconds
        # time.sleep(10)
        self.parsingComplete = 1

    def add(self, name, type, pathList, info=None):
        if not pathList:
            if not name in self.children:
                # print 'new: info = ', info
                self.children[name] = [Container(name, type, self, info=info)]
            else:
                # This part is to handle function overloading. Basically,
                # if we have found a function and there is already a
                # function defined with the same name, then we want to add
                # a new member
                # print 'old: info = ', info
                if self.children[name][-1].type is not None:
                    self.children[name].append(Container(name, type, self,
                                                         info=info))
                else:
                    self.children[name][-1].type = type
                    self.children[name][-1].info = info
        else:
            if not pathList[0] in self.children:
                # as of now, we do not know the type or information about
                # this object. Later, when we come across the object
                # definition, these fields will be set.
                self.children[pathList[0]] = [Container(pathList[0], None, self, info=None)]

            # now push this object downstream.
            self.children[pathList[0]][0].add(name, type, pathList[1:], info=info)

    def getObject(self, path, activeNamespaces=[]):
        """
        @path:
            the path to the container which we want to find.
            Ex:
                ['CG', 'AddExpr']
                This corresponds to something like CG::AddExpr
        @activeNamespaces:
            The namespaces which are active at this point. This is another list
            of lists arising from `using namespace` declarations.
            Ex:
                [['ns1'], ['ns2', ns3]]
                from
                using ns1;
                using ns2::ns3;
        """
        for nameSpace in activeNamespaces + [[]]:
            retval = self._getObject(nameSpace + path)
            if retval:
                return retval

    def _getObject(self, path):
        if not path:
            return self
        else:
            if path[0] in self.children:
                return self.children[path[0]][0]._getObject(path[1:])
            else:
                return None

    def toString(self, prefix=''):
        ret = '%s%s (%s) [%s]\n' % (prefix, self.name, self.type, self.info)
        for name, children in self.children.items():
            for ch in children:
                ret += ch.toString(prefix=prefix+'  ')
        return ret

    def getMemberList(self, path, activeNamespaces):
       container = self.getObject(path, activeNamespaces)
       list = container._getMemberList(self, activeNamespaces)

       return list

    def _getMemberList(self, root, activeNamespaces=[]):
        retval = self.children.values()
        if self.type == 'c' and self.info:
            if 'inherits' in self.info:
                parentName = self.info['inherits'].split('::')
                # NOTE: We need to add the namespace of this object itself
                parentObj = root.getObject(parentName,
                                           activeNamespaces=activeNamespaces)
                if parentObj:
                    retval += parentObj._getMemberList(root,
                                                      activeNamespaces=activeNamespaces)
        return retval

    def searchUpwards(self, name):
        if name in self.children:
            return self
        else:
            if self.parent:
                return self.parent.searchUpwards(name)
            else:
                return None

    def searchUpwardsThroughClass(self, name, root, activeNamespaces):
        if name in self.children:
            return self
        elif self.type == 'c' and self.info and 'inherits' in self.info:
            parentName = self.info['inherits'].split('::')
            # NOTE: We need to add the namespace of this object itself
            parentObj = root.getObject(parentName,
                                       activeNamespaces=activeNamespaces)
            if parentObj:
                return parentObj.searchUpwardsThroughClass(name, root,
                                                           activeNamespaces)
        else:
            return None

    def resolveTypedefs(self, object):
        if object and object.type == 't':
            typedef = object.info['typedef'].split(':')[1]
            finalType = self.getFinalType([typedef], [['CG']])
            return finalType
        else:
            return object

    def getFinalType(self, callList, activeNamespaces=[]):
        """
        This function finds the final return type of a series of function
        calls. It is meant to resolve things like:

            foo()->bar()->baz()

        where foo() returns a structure which has bar as a member which
        is itself a function which returns a structure which has baz as a
        member and so on. We finally want to return the type of the
        complete expression.
        """
        first = callList[0]
        firstObject = self.getObject([first], activeNamespaces)
        firstObject = self.resolveTypedefs(firstObject)
        if firstObject:
            finalType = firstObject._getFinalType(callList[1:], self, activeNamespaces)
            return self.resolveTypedefs(finalType)
        else:
            return None

    def _getFinalType(self, callList, root, activeNamespaces=[]):
        if not callList:
            return self
        else:
            first = callList[0]
            container = self.searchUpwardsThroughClass(first, root,
                                                       activeNamespaces)
            if not container:
                return None
            
            container = container.children[first][0]
            if container.type == 'c' or container.type == 'n':
                return container._getFinalType(callList[1:], root,
                                          activeNamespaces)
            elif container.type == 'f' or container.type == 'm':
                if not container.info:
                    return None

                returnType = container.info['returnType']
                container = root.getObject([returnType],
                                           activeNamespaces=activeNamespaces)
                if not container:
                    return None

                return container._getFinalType(callList[1:], root,
                                              activeNamespaces)

    def __str__(self):
        return self.toString()

class ParseTagsFileThread (Thread):
    def __init__(self, globalNamespace, filenames):
        Thread.__init__(self)
        self.tagsFilenames = filenames
        self.globalNamespace = globalNamespace

    def run(self):
        for fname in self.tagsFilenames:
            if not os.path.isfile(fname):
                continue
            self.globalNamespace.parseFile(fname)

# A cool list flattening function from comp.lang.python <<<
import sys
import types
def flatten(inlist, type=type, listtype=types.ListType, \
     integers = xrange(sys.maxint), endoflist=IndexError):
    '''
    Destructively flatten a list hierarchy to a single level.
    Non-recursive, and (as far as I can see, doesn't have any
    glaring loopholes).

    Provided by Tim Peters, Mike Fletcher and Christian Tismer
    on comp.lang.python
    '''
    try:
        for ind in integers :
            while type(inlist[ind]) is listtype:
                inlist[ind:ind+1] = inlist[ind]
    except endoflist:
        return inlist 

# >>>

# only when importing into vim <<<
try:
    import vim
except:
    pass

import re
def vimDebug(str):
    vim.eval('Debug(%s, "myomni")' % str.__repr__())

class VimTagsCompleter:
    def __init__(self):
        self.root = Container('Head', 'n', None, info=None)
        self.tagsFiles = vim.eval('&tags').split(',')
        self.pthread = ParseTagsFileThread(self.root, self.tagsFiles)
        self.pthread.start()

    def performCompletion(self, prefix):
        self.pthread.join()

        if prefix:
            curpos = vim.current.window.cursor
            lastToken = vim.eval('GetLastToken()')
            vim.current.window.cursor = curpos
            if lastToken == '->':
                wordChain = vim.eval('GetWordChain()')
            else:
                wordChain = []
        else:
            wordChain = vim.eval('GetWordChain()')

        vimDebug('wordChain = %s, prefix = %s' % (wordChain, prefix))
        if wordChain:
            if not self.root.getObject([wordChain[0]], [['CG']]):
                vimDebug('Attempting to figure out if there is a type declaration for this word')
                wordType = vim.eval('GetWordType(%s)' % wordChain[0].__repr__())
                if wordType:
                    wordChain[0] = wordType
                vimDebug('with first item replaced wordChain = %s' % wordChain)

            finalType = self.root.getFinalType(wordChain, [['CG']])

            if not finalType:
                return
            vimDebug('finalType = %s' % finalType.name)

            # if this is a typedef'ed symbol, then we need to find the
            # members of the class to whic it is typedef-ed.
            if 'typedef' in finalType.info:
                typedef = finalType.info['typedef'].split(':')[1]
                finalType = self.root.getFinalType([typedef], [['CG']])

            #vimDebug('finalType after typedef resolution = %s' % finalType)

            list = finalType._getMemberList(self.root, [['CG']])
            vimDebug('getting %d completions' % len(list))
            flatten(list)
        else:
            list = self.root.children.values()
            list2 = self.root.children['CG'][0].children.values()
            list.extend(list2)
            flatten(list)

        # here we follow the recommended "decorate-sort-undecorate"
        # idiom for sorting lists without using a custom cmp function
        # in order to get the maximum speed from the sort.
        # The term i is to maintain the original order when the names
        # are equal.
        decoList = [(item.name.lower(), i, item) for i, item in enumerate(list)]
        decoList.sort()
        finalList = [item for _, _,item in decoList]

        prefre = re.compile(prefix)
        prevItem = None
        for item in finalList:
            # The following conditions need to be met for an item to be
            # listed:
            # 1. It should not be a constructor or destructor.
            # 2. It should not be a function already defined in a child
            #    class.
            if (prefre.match(item.name) and 
                item.name != item.parent.name and
                item.name != ('~'+item.parent.name) and
                (prevItem is None or item.name != prevItem.name or 
                 prevItem.parent.name == item.parent.name)):

                if not item.info:
                    continue

                d = {'word': item.name, 'kind': item.type, 
                     'menu': item.parent.name, 
                     'info': item.info['location'],
                     'dup': 1 }
                vim.eval('complete_add(%s)' % d.__repr__())
                prevItem = item

# >>>

if __name__ == "__main__":
    root = Container('Head', 'n', None, info=None)
    tagsFiles = sys.argv[1:]
    if not tagsFiles:
        print 'No tags files found'
        sys.exit(0)

    pthread = ParseTagsFileThread(root, tagsFiles)
    pthread.start()

    for i in range(5):
        print 'doing something else'
        time.sleep(0.1)

    pthread.join()

    members = root.getMemberList(['DB_data'], [])
    flatten(members)
    decoList = [(item.name, i, item) for i, item in enumerate(members)]
    decoList.sort()
    finalList = [item for _, _,item in decoList]

    print '--------before-------------'
    for m in finalList:
        print '%s: %s (%s)' % (m.name, m.parent.name, m.info)

    i = 1
    while 1:
        try:
            if (finalList[i].name == finalList[i-1].name):
                finalList.pop(i)
            else:
                i += 1
        except:
            break

    print '--------after-------------'
    for m in finalList:
        print '%s: %s' % (m.name, m.parent.name)
